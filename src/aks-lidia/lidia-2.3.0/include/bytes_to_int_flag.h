// This file is automatically generated -- do not modify!
// Copyright (c) 2005 the LiDIA Group.
// See http://www.informatik.tu-darmstadt.de/TI/LiDIA/

#ifdef LIDIA_NAMESPACE
namespace LiDIA {
#endif


  /*************************************/
  /*  bytes_to_int_flag<inttype, idx>  */
  /*************************************/

  // Constants that describe the mapping of byte arrays to
  // integral types, used, e.g., in MPQS.
  // Let T be an integral type and c an unsigned char array of
  // length sizeof(T). Then
  //   bytes_to_int_flag<T, j>::value == *reinterpret_cast<T*>(c)
  // provided 0 <= j < sizeof(T), c[j] == 0xff, and
  // c[i] == 0x00 for all i != j.

  template<typename T, int idx>
  struct bytes_to_int_flag;

  template<>
  struct bytes_to_int_flag<char, 0> {
    static char const value = 0xff;
  };

  template<>
  struct bytes_to_int_flag<signed char, 0> {
    static signed char const value = 0xff;
  };

  template<>
  struct bytes_to_int_flag<unsigned char, 0> {
    static unsigned char const value = 0xff;
  };

  template<>
  struct bytes_to_int_flag<short, 0> {
    static short const value = 0x00ff;
  };

  template<>
  struct bytes_to_int_flag<short, 1> {
    static short const value = 0xff00;
  };

  template<>
  struct bytes_to_int_flag<unsigned short, 0> {
    static unsigned short const value = 0x00ff;
  };

  template<>
  struct bytes_to_int_flag<unsigned short, 1> {
    static unsigned short const value = 0xff00;
  };

  template<>
  struct bytes_to_int_flag<int, 0> {
    static int const value = 0x000000ff;
  };

  template<>
  struct bytes_to_int_flag<int, 1> {
    static int const value = 0x0000ff00;
  };

  template<>
  struct bytes_to_int_flag<int, 2> {
    static int const value = 0x00ff0000;
  };

  template<>
  struct bytes_to_int_flag<int, 3> {
    static int const value = 0xff000000;
  };

  template<>
  struct bytes_to_int_flag<unsigned int, 0> {
    static unsigned int const value = 0x000000ff;
  };

  template<>
  struct bytes_to_int_flag<unsigned int, 1> {
    static unsigned int const value = 0x0000ff00;
  };

  template<>
  struct bytes_to_int_flag<unsigned int, 2> {
    static unsigned int const value = 0x00ff0000;
  };

  template<>
  struct bytes_to_int_flag<unsigned int, 3> {
    static unsigned int const value = 0xff000000;
  };

  template<>
  struct bytes_to_int_flag<long, 0> {
    static long const value = 0x000000ff;
  };

  template<>
  struct bytes_to_int_flag<long, 1> {
    static long const value = 0x0000ff00;
  };

  template<>
  struct bytes_to_int_flag<long, 2> {
    static long const value = 0x00ff0000;
  };

  template<>
  struct bytes_to_int_flag<long, 3> {
    static long const value = 0xff000000;
  };

  template<>
  struct bytes_to_int_flag<unsigned long, 0> {
    static unsigned long const value = 0x000000ff;
  };

  template<>
  struct bytes_to_int_flag<unsigned long, 1> {
    static unsigned long const value = 0x0000ff00;
  };

  template<>
  struct bytes_to_int_flag<unsigned long, 2> {
    static unsigned long const value = 0x00ff0000;
  };

  template<>
  struct bytes_to_int_flag<unsigned long, 3> {
    static unsigned long const value = 0xff000000;
  };


  /*********************/
  /*  int32 constants  */
  /*********************/

  struct int32_consts {
    static int const octets_0_1_0xff = 0x0000ffff;
    static int const octets_2_3_0xff = 0xffff0000;
    static int const octet_0_0xff = 0x000000ff;
    static int const octet_1_0xff = 0x0000ff00;
    static int const octet_2_0xff = 0x00ff0000;
    static int const octet_3_0xff = 0xff000000;

    static int const octets_0_1_0x80 = 0x00008080;
    static int const octets_2_3_0x80 = 0x80800000;
    static int const octet_0_0x80 = 0x00000080;
    static int const octet_1_0x80 = 0x00008000;
    static int const octet_2_0x80 = 0x00800000;
    static int const octet_3_0x80 = 0x80000000;
  };


  // no 64 bit int type found

#ifdef LIDIA_NAMESPACE
} // namespace LiDIA
#endif

